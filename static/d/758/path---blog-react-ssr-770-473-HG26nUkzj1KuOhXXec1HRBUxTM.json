{"data":{"site":{"siteMetadata":{"title":"dwb-blog","author":"dwb"}},"markdownRemark":{"id":"d1996268-87cd-5462-9912-54dc736a8aad","html":"<h3>一、什么是服务端渲染：</h3>\n<p>服务端渲染（SSR）区别于客户端渲染（CSR），当用户访问一个网址的时候，客户端渲染则是服务端返回一部分 HTML 结构，通过执行 JavaScript 将余下的 HTML 渲染到页面上，而服务端渲染则是在服务端生成完整的 HTML 结构返回给浏览器。\n以 React 为例：在客户端渲染时一般 html 的 body 中只有一个 id 为 root 的标签，页面在浏览器上渲染出来后，通过执行 JavaScript 将页面内容插入到这个标签中。而服务端渲染则在服务器端将页面内容插入到这个标签中，返回给浏览器的时候就已经有完整的页面结构了。</p>\n<p>由此我们可以看到服务端渲染具有如下优势：</p>\n<ol>\n<li>首屏渲染快：返回的 html 是完整的，不需要再发其他请求来不断地向页面填充内容，也不会在渲染过程中产生白屏或抖动，用户体验会好很多</li>\n<li>有利于 SEO：React 客户端渲染页面中只有一个 root 标签，搜索引擎很难爬取页面内容，而服务端渲染能给搜索引擎更多的数据，因此能获得更高的权重和排名</li>\n</ol>\n<p>服务端渲染的这些优势，伴随着一定的代价：</p>\n<ol>\n<li>项目架构变得复杂，维护成本提高：客户端渲染时前端工程师只关注 JS，而做服务端渲染的话，则不仅需要关注同构部分的代码，还要关注 Node 服务端的代码；不仅要保证同构代码的正常运行，还要保证 Node 服务稳定。前端的 Node 服务部署上去之后，需要付出时间精力来进行服务器的运维</li>\n<li>服务端执行 react 性能消耗较大，对 Node SSR 服务器性能损耗更多，对网速、并发数都是考验</li>\n</ol>\n<h3>二、什么是同构：</h3>\n<p>用同一份代码在服务端和客户端分别执行一次。代码在服务端执行时渲染了页面，在客户端执行时接管了页面交互。</p>\n<p>这样做是因为事件绑定处理是浏览器的行为，服务端代码只能生成 html string，而客户端代码执行的时候使用 ReactDOM.hydrate 进行事件绑定。</p>\n<h3>三、怎样实现？</h3>\n<p>看完了上面这些概念，我们知道看了 SSR 的优势，那么如何用代码实现呢？</p>\n<p>一个最简单的，基于 Koa 的 SSR 实现如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> Koa <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'koa'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> app <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Koa</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\napp<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span>ctx <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  ctx<span class=\"token punctuation\">.</span>body <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token string\">`\n    &lt;html>\n      &lt;head>\n          &lt;title>title&lt;/title>\n      &lt;/head>\n      &lt;body>\n          hello SSR\n      &lt;/body>\n    &lt;/html>\n  `</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\napp<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>网页上展示的内容都是服务器端返回的，这样只做到了服务器端渲染，没有做同构处理，当页面复杂一些，有一些交互的时候就不行了。</p>\n<p>引入 React 同构之后，一次完整的 React 同构 SSR 主要流程如下：</p>\n<img src=\"/img/react-ssr/流程.png\" style=\"width:100%; max-width: 661px;\" />\n<p>具体怎样实现呢？下面讲下几个关键步骤</p>\n<h4>1. 环境搭建</h4>\n<p>从上面的流程图可以看出，我们至少需要打包两份代码：一份是服务器端代码，用于 Node 端起服务、渲染页面；另一份是浏览器端拿到 html 文件后请求的 bundle.js</p>\n<h3>有哪些操作细节？</h3>\n<p>router的坑，客户端有history api，服务端只有路径</p>\n<ol>\n<li>webpack 打包环境区分</li>\n<li>同构处理</li>\n<li>数据脱水和注水</li>\n<li>请求认证</li>\n<li>样式打包</li>\n<li>meta tags 渲染</li>\n<li>403、404 处理</li>\n<li>安全问题</li>\n<li>性能优化</li>\n</ol>\n<h3>思考</h3>\n<p>Node 做为中间层，做了这几件事：</p>\n<ol>\n<li>在服务端渲染 React 代码</li>\n<li>进行工程解耦，有利于排查错误</li>\n<li>服务端执行 react 性能消耗较大，因此将 Node 服务单独分出来，负载遇到瓶颈时可以单独加 Node 机器来解决</li>\n<li>接口代理与转发：解决跨域问题</li>\n</ol>","frontmatter":{"title":"浅谈 React 服务端渲染与同构","date":"May 28, 2020"},"excerpt":"一、什么是服务端渲染： 服务端渲染（SSR）区别于客户端渲染（CSR），当用户访问一个网址的时候，客户端渲染则是服务端返回一部分 HTML 结构，通过执行 JavaScript 将余下的 HTML 渲染到页面上，而服务端渲染则是在服务端生成完整的 HTML 结构返回给浏览器。\n以 React 为例：在客户端渲染时一般 html 的 body 中只有一个 id 为 root 的标签，页面在浏览器上渲染出来后，通过执行 JavaScript…"}},"pageContext":{"slug":"/blog/react-ssr/","previous":{"fields":{"slug":"/reading/2019-07-25-js-you-dont-know-1/"},"frontmatter":{"title":"你不知道的 JavaScript (上)","type":"reading","photos":null,"tags":["JS"],"process":[100,100]}},"next":{"fields":{"slug":"/about/"},"frontmatter":{"title":"","type":"other","photos":null,"tags":null,"process":null}}}}